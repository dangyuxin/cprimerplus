# 2022linux面试题题解

## 0.我的计算器坏了

```math2^2=1024对应于10进制的4位,
那么2^{10000}对应于十进制的多少位呢
？```
解:
```math1. 我们知道10^0是一位数
，10^1是两位数，那么10^{n}就对应n-1位数
，所以我们要知道2^{10000}是多少位
，即求log_{10}2^{10000}的值减去1即可。

 log_{10}2^{10000}=1000log_{10}1024≈1000*3.010299
1. 即3000+位。
```
## 1.printf还能这么玩？

```c
int main(void) {
if ((3 + 2< 2) > (3 + 2 > 2))
printf("Welcome to xiyou Linux Group\n"); else
printf("%d\n"，printf("xiyou Linux Group - 2%d",printf("")));

```
首先判断if可知结果为假，走else
打印%d就要取决于逗号后面的返回值，后面又是个printf函数
就是嵌套，接着看，打印xiyou linux group -2%d，这里的%d又要看后面，后面打印空，返回值为0，
所以上面打印出了-20；接着返回第一层，第二层内字符数总共为22个，即返回值为22，打印22；
最终结果为Xiyou Linux Group -2022.
## 2.你好你好你好呀!
●程序的输出有点奇怪，请尝试解释一下程序的输出吧。
●请谈谈你对sizeof(()与strlen()的理解吧。

```c
int main(void)
{
    char p0[] = "Hello,Linux";
    char *p1 = "Hello,Linux";
    char p2[11] = "Hello,Linux";
    printf("p0==p1: %d, strcmp(p0,p2): %d\n", p0 == p1, strcmp(p0, p2));
    printf("sizeof(p0): %zu, sizeof(p1): %zu, sizeof(*p2): %zu \n",
           sizeof(p0), sizeof(p1), sizeof(*p2));
    printf("strlen(p0): %zu, strlen(p1): %zu\n", strlen(p0), strlen(p1));
}
```
p0==p1: 0, strcmp(p0,p2): -72
sizeof(p0): 12, sizeof(p1): 8, sizeof(*p2): 1
strlen(p0): 11, strlen(p1): 11
strcmp自左向右逐个按照ASCII码值进行比较，直到出现不同的字符或遇’\0’为止。
如果返回值 < 0，则表示 s1 小于 s2。
如果返回值 > 0，则表示 s1 大于 s2。
如果返回值 = 0，则表示 s1 等于 s2
%d输出int型，%zu输出size_t型。size_t在库中定义为unsigned int。
一个是整型，一个是无符号整型。

int是4个字节，unsigned int是8个字节
1.p0和p1的内容相同，所以strcmp打印出0，这里看似p0与p1内容相同，实则p0末尾还存在\0，所以两者不同，根据strcmp是按照ascll码打印可知打印出-72；
而sizeof与strlen的区别是，sizeof对象是各种数据类型，计算它们的大小，单位是字节，而strlen是针对字符串，用来计算字符串的长度，sizeof在计算字符串大小的时候会计算到字符串末尾的\0；而strlen不会，
## 3.换个变量名不行吗?
请结合本题，分别谈谈你对C语言中「全局变量」和「局部变量」的「生命周期理解。

```c
int a = 3;
void test(){ 
int a = 1;
a += 1;
int a = a + 1;
printf("a = %d\n"，a);
printf("a = %d\n"，a);
int main(void){
test();
printf("a =%d\n"，a);
```
1 局部变量：“在函数内定义的变量”，

　　　　　　即在一个函数内部定义的变量，只在本函数范围内有效。

　　2 全局变量：“在函数外定义的变量”，

　　　　　　即从定义变量的位置到本源文件结束都有效。
　　　　　　局部变量的生命周期就是变量所在的局部范围。
　　　　　　全局变量的生命周期可以说是整个工程。
　　　　　　
## union与struct各有什么特点呢，你了解他们的内存分配模式吗。

```c
typedef union { 
long l; 
int i[5]; 
char c;} UNION;
typedef struct { int like; UNION coin;
double collect;} STRUCT;
int main(void){ 
printf("sizeof(UNION) = %zu\n",sizeof(UNION)); 
printf("sizeof(STRUCT)=%zu\n"，sizeof(STRUCT));
```
union和struct都是由多个不同的数据类型成员组成， 但在任何同一时刻， union只存放一个被选中的成员， 而struct则存放所有的成员变量。
对于union的不同成员赋值，将会对其他成员重写， 原来成员的值就不存在了， 而对于struct的不同成员赋值是互不影响的。
二者的内存分配不同。union的大小为其内部所有变量的最大值。

## 5.Bitwise
请使用纸笔推导出程序的输出结果。请谈谈你对位运算的理解。

```c
int main(void){
unsigned char a=4|7; a <<= 3;
unsigned char b =5 &7; b >>= 3:
unsigned char c= 6 ^7; c=:
unsigned short d =(a ^ c) << 3; signed char e=-63; e <<= 2;
printf("a:%d，b:%d，c:%d，d:%d\n"，a，b，c，(char)d); printf("e:%#x\n"，e);
```
signed char 的范围：-128-127
unsigned char 的范围：0-255
4是100，7是111
4或7
结果为111
是7
左移3位变成
111000
就是32+16+8
56
-63是
10111111
反码是01000000
补码为01000001
向左移位2
变成00000100
就是4
5是101
7是111
与运算后是 101
右移三位后是0；
6和7亦或
结果为1
再取反
是254

## 6.英译汉
请说说下面数据类型的含义，谈谈const的作用。

```c
1) char *const p
2)char const *p
3) const char *p 
```
1.const修饰p，即指针是常量，不可改变,指向的内容可以改变。
2.字符是常量，指针 p 可以改变，指向的常量值不能改
3.与二同理
## 7.汉译英
请用变量p给出下面的定义:
1)含有10个指向int的指针的数组。
2)指向含有 10个 int 数组的指针。
3)含有3个「指向函数的指针」的数组，被指向的函数有1个int参数并返回int

1.int*p[10]
2.int(*p)[10]

## 8.混乱中建立秩序
你对排序算法了解多少呢?
请谈谈你所了解的排序算法的思想、稳定性、时间复杂度、空间复杂度。
提示:动动你的小手敲出来更好哦~

排序有交换排序，直接排序，插入排序，快速排序，堆排序等等，排序的稳定性就是相同大小的元素在排序之后依然保持相对位置不变。而时间和空间的复杂度取决于该排序是否分支和是否需要额外分配空间。
平均时间复杂度：冒泡、选择、插入都不是分支法平均时间复杂的都是O(n^2)，基于分支法的快速排序和堆排序都是O(n*log2n)。
空间复杂度：不需要额外空间的冒泡、选择、插入、堆排序空间复杂度都是O(1)，需要额外空间快速排序空间复杂度是O(log2n)-O(n)。

## 9.手脑并用
请实现ConvertAndMerge函数:
拼接输入的两个字符串，并翻转拼接后得到的新字符串中所有字母的大小写。提示:你需要为新字符串分配空间。

```c
char* convertAndMerge( char words[ 2][20]){

char str1 =words[0];
char str2 =words[1];
char* str3 = (char *) malloc(1 + strlen(s1)+ strlen(s2));

for(int i=0;i<20;i++){
if(str1[i]>='A'&&_str1[i]<='Z'){ stri[i] = str1[i]+32;
}
if(str1[i]>='a’ && str1[i]<='z'){
str1[i] = str1[i]-32;
}
strcpy(str3,str1);
strcat(str3, str2);
return str3;
```


```c
char* convertAndMerge(/*补全签名*/);
int main(void){
char words[2][20] = {"Welcome to Xiyou ","Linux Group 2022"};
printf("%s\n"，words[0]);
printf("%s\n"，words[1]);
char*str=convertAndMerge(words);
printf("str =%s\n"，str); 
free(str);
```
## 10.给你我的指针，访问我的心声
程序的输出有点奇怪，请尝试解释一下程序的输出吧 

```c
int main(int argc, char **argv){ 
int arr[5][5]; 
int a = 0;
for (int i = 0; i <5; i++) {
int *temp = *(arr + i);
for(;temp<arr[5];temp++)
*temp = a++;
}
for (int i = 0; i < 5;i++) {
for (int j = 0; j<5; j++) {
printf("%d\t"，arr[i][j]);
}
}
}
```

这个题就是个跳跃赋值，我们先分别打印每次循环后数组的结果看看
0	1	2	3	4	
5	6	7	8	9	
10	11	12	13	14	
15	16	17	18	19	
20	21	22	23	24	
0	1	2	3	4	
25	26	27	28	29	
30	31	32	33	34	
35	36	37	38	39	
40	41	42	43	44	
0	1	2	3	4	
25	26	27	28	29	
45	46	47	48	49	
50	51	52	53	54	
55	56	57	58	59	
0	1	2	3	4	
25	26	27	28	29	
45	46	47	48	49	
60	61	62	63	64	
65	66	67	68	69	
0	1	2	3	4	
25	26	27	28	29	
45	46	47	48	49	
60	61	62	63	64	
70	71	72	73	74
这时我们就明白，第一次循环从第一行开始赋值，第二次从第二行开始赋值，整个过程中a从0一直自增到75；就有了如上的输出结果。

## 11.奇怪的参数
你了解 argc和argv 吗?
直接运行程序argc的值为什么是1?程序会出现死循环吗?

```c
int main(int argc, char **argv){
printf("argc = %d\n"，argc);
while(1){ 
argc++;
if (argc< 0) {
printf("%s\n"，(char *)argv[0]); 
break;
}}
```

argc是输入main的参数个数
argv是输入main的参数序列
argv0一般是表示程序名
所以真正输入的参数
应该是argc-1
所以argc初始值就是1
没有输入参数直接打印
打印出来的就是程序路径的名称
，这里看似会有死循环，实则int有上限，等超过上限就会溢出成为负数，就会跳出循环。
## 12.奇怪的字符
程序的输出有点奇怪，请尝试解释一下程序的输出吧。 
```c
int main(int argc, char **argv) {
int data1[2][3]={{0X636c6557，0x20656d6f，0x58206f74}
{0X756f7969，0X6e694c20，0x00000000}};
int data2]={0X47207875,0X70756f72,0x32303220，0x00000a321};
char *a=(char*)data1;
char *b=(char*)data2; 
char buf[1024];
strcpy(buf，a);
strcat(buf，b);
printf("%s\n"，buf);
}
```
这里date里存储的是16进制整形，随后又将其转化为char类型并输出，所以要根据数字对应的ascll码值进行转化，即两位对应一个字符，又因为c语言中存在大小端
大端存储模式：是指数据的低位字节序保存在内存的高地址中，而数据的高位字节序保存在内存的低地址中
小端存储模式：是指数据的低位字节序保存在内存的低地址中，而数据的高位字节序保存在内存的高地址中
所以最终打印时为倒序打印。

## 13.小试宏刀
●请谈谈你对#define的理解。
请尝试着解释程序的输出。

```c
#define SWAP(a，b.t)t=a:a=b;b=t
#define SQUARE(a) a *a
#define SWAPWHEN(a,b,t, cond) if (cond) SWAP(a, b, t) 
int main({
int tmp; int x= 1; int y = 2; int z =3; int w = 3;
SWAP(x，y，tmp);
printf("x = %d， y = %d，tmp =%d\n"，x，y，tmp); 
if(x> y) SWAP(x，y，tmp);
printf("x =%d， y =%d，tmp =%d\n"，x，y，tmp);
SWAPWHEN(x，y，tmp，SQUARE(1+ 2+z+++++w)==100); 
printf("x=%d，y=xd\n"，x，y);
printf("z=%d，w=%d，tmp=%d\n"，z，w，tmp);
}
```
#define即宏定义，宏定义一般分带参与不带参两种。本题使用的是带参宏定义，宏不能像函数那样递归，且宏无需声明特定的数据类型。

x = 2, y = 1, tmp = 1
x = 1, y = 2, tmp = 2
x = 2, y = 2,tmp=2
z = 5, w = 5 ,tmp = 2


首先第一次交换 x,y,t的值，根据宏定义
有x = 2, y = 1, tmp = 1；
此时x>y,if成立，继续交换一次有
x = 1, y = 2, tmp = 2；
此时根据第三个宏定义，当if里的条件成立时，才进行交换，这里的z++和++w都是自增，但++w是先增后运算，z++相反，所以结果并非100，条件不成立，只执行a=b;b=t;
有x=2；y=2；
zw分别自增两次为5，t为2；
## 14.GNU/Linux命令(选做)你知道以下命令的含义和用法吗:
注:
嘿!你或许对Linux命令不是很熟悉，甚至你没听说过Linux。但别担心，这是选做题，不会对你的面试产生很大的影响!了解Linux是加分项，但不了解也不扣分哦!
ls
rm
whoami
请问你还了解哪些GNU/Linux的命令呢。


ls 列举目录，
rm 删除，
whoami 显示用户名，

其他的变量还有 cd 切换目录，mkdir创建目录  touch创建文件夹等等











